# 📘 Meeting Assistant 消息系统：精简开发计划（MVP 优先版）

> **目标**：以最小可行实现用户级实时消息推送，避免过早优化和架构膨胀  
> **原则**：能用内存就不用 Redis Pub/Sub，能复用就不重写，能推迟就不提前  
> **当前时间**：2025年10月17日

---

## 📊 当前项目状态（继承自原计划）

✅ JWT 用户认证已完整实现  
✅ 基础消息系统（MessageService + API）已就绪  
✅ MySQL 消息表结构支持多接收者（`message_recipients`）  
✅ Redis 缓存集成（消息列表、未读计数）已可用  
✅ WebSocket 基础框架（ConnectionManager）已存在  

➡️ **结论**：基础设施足够支撑 MVP 实时推送，无需额外中间件

---

## 🎯 调整策略：聚焦“用户能实时收到消息”这一核心体验

- 暂不实现 Redis Pub/Sub、消息队列、在线状态持久化、监控仪表盘等非核心功能
- 使用内存管理 WebSocket 连接（初期用户量可控）
- 推送逻辑直接嵌入消息发送流程（简单、低延迟、易调试）
- 离线用户依赖已有 API 拉取（无需复杂同步机制）

---

## 🔹 阶段 1：最小可行实时推送系统（MVP）｜工期：5–7 天

### 📌 目标
用户通过 WebSocket 实时接收新消息，支持 JWT 认证与多设备连接。

### ✅ 核心任务
| 任务 | 说明 |
|------|------|
| 新增用户消息 WebSocket 路由 | 路径：`/ws/messages`，通过 `token` 查询参数验证 JWT |
| 内存连接管理器 | `active_connections: Dict[user_id, List[WebSocket]]` |
| 消息发送时实时推送 | 若接收者在线，直接遍历其 WebSocket 列表发送 |
| 连接生命周期管理 | 连接建立/断开时自动注册/注销 |
| 重连后补推未读消息 | 连接成功后调用现有 `/messages/unread` 接口推送一次 |

### 🚫 暂不实现
- Redis 在线状态存储
- 心跳检测与自动清理（依赖异常捕获兜底）
- 消息送达确认
- 多进程/集群支持（单实例足够）

### ✅ 验收标准
| 测试项 | 预期结果 |
|--------|----------|
| 1. 用户携带有效 token 连接 WebSocket 成功 | ✔️ |
| 2. 发送消息后，在线用户实时收到推送 | ✔️ |
| 3. 多设备同时在线均能收到消息 | ✔️ |
| 4. 离线用户消息正常存储，登录后可拉取 | ✔️（复用现有 API） |
| 5. 会议 WebSocket 功能不受影响 | ✔️（路由隔离） |

---

## 🔹 阶段 2：轻量可靠性增强｜工期：3–5 天（可选，按需启动）

### 📌 目标
提升连接稳定性与用户体验，为小规模生产环境做准备。

### ✅ 核心任务
| 任务 | 说明 |
|------|------|
| 自动清理断开连接 | 捕获 WebSocket 异常，从 `active_connections` 移除 |
| 防止内存泄漏 | 定期清理空用户列表（如每小时） |
| 简单在线状态标记（可选） | 用 Redis Hash `online_users` 记录 user_id → timestamp |
| 统一消息格式 | 定义标准 JSON Schema（含 type、payload、timestamp） |

### ✅ 验收标准
| 测试项 | 预期结果 |
|--------|----------|
| 1. 断网/刷新后连接自动清理 | ✔️ |
| 2. 重连后未读消息正确补推 | ✔️ |
| 3. 消息格式一致，前端可解析 | ✔️ |

---


## 🗺️ 实施路线图（精简版）

```
✅ 基础设施就绪
  ↓
🚀 阶段 1：MVP 实时推送（立即开始）
  ↓
⚡ 阶段 2：可靠性增强（按需）

```

### 开发优先级
| 优先级 | 阶段 | 理由 |
|--------|------|------|
| 🔥 最高 | 阶段 1 | 用户最需要的实时能力，1 周内可见效 |
| ⚠️ 中等 | 阶段 2 | 提升稳定性，适合小规模上线 |

---

## 🛠️ 技术实现要点（极简架构）

```text
+------------------+
|  MessageService  |
|  .send_message() |
+--------+---------+
         | (直接调用)
         v
+------------------+     +---------------------+
| active_connections|<--->| WebSocket /ws/messages |
| Dict[user_id, WS]|     | JWT 验证 + 推送      |
+------------------+     +---------------------+
         ^
         | (重连时调用)
+------------------+
| /messages/unread |
| (现有 API)       |
+------------------+
```

- **无消息队列**
- **无 Pub/Sub**
- **无独立消费者进程**
- **推送 = 发消息时同步遍历 WebSocket**

---

## ✅ 质量与风险控制

| 项目 | 策略 |
|------|------|
| **兼容性** | 不修改现有 API，新功能通过新 WebSocket 路由提供 |
| **降级能力** | WebSocket 失败不影响消息存储，用户仍可拉取 |
| **性能风险** | 初期用户少，内存管理足够；后续可替换为 Redis Set |
| **安全** | 复用现有 JWT 验证，WebSocket 握手即认证 |
| **回滚** | 删除 WebSocket 路由即可，无数据库变更 |

---

## 📋 实施检查清单

### 开发过程
- [ ] 阶段 1：用户 WebSocket 路由 + 内存连接管理 + 实时推送
- [ ] 阶段 2（可选）：连接清理 + 未读补推 + 消息格式标准化

### 质量保证
- [x] 复用现有单元测试（MessageService、AuthService）
- [ ] 新增 WebSocket 集成测试（连接、推送、断开）
- [ ] 手动测试多设备场景

### 文档
- [ ] 更新 API 文档：新增 `/ws/messages` 说明
- [ ] 前端对接指南：消息 JSON 格式示例

---

## 🎯 总结

- **当前状态**：基础设施完备，可直接开发实时推送  
- **下一步行动**：立即启动 **阶段 1（MVP 实时推送）**  
- **预期成果**：用户登录后能**实时收到新消息**，显著提升体验  
- **核心优势**：**代码少、风险低、见效快**，且**不阻碍未来扩展**

> 💡 **记住**：先让用户“能用”，再让他们“好用”。复杂性，留给增长后的你。

--- 
